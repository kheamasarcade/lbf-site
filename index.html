# exporter.py
# Kheama's Arcade • Lurk Bait Fishing — robust exporter
# - Reads CatchData.txt, DexData.txt, PlayerData.txt
# - Parses dates like "3/3/2024 5:05:48 PM" in LOCAL time
# - Exports:
#     recent.json        -> last 50 catches (sorted newest first)
#     season_bests.json  -> best gold per species (all-time, with rarity, player, timestamp)
#     players.json       -> season + lifetime stats per player
#     leaderboard.json   -> ranks by SEASON gold
#     meta.json          -> exported_at + season_start_epoch
#
# Run:
#   (.venv) PS D:\Projects> python D:\Projects\lurkbait_app_v2\exporter.py

import os, json, datetime, time, sys
from collections import defaultdict

# ---------- CONFIG ----------
BASE = os.path.expanduser(r"C:\Users\sdmac\AppData\LocalLow\BLAMCAM Interactive\LurkBait Twitch Fishing")
CATCH_FILE  = os.path.join(BASE, "CatchData.txt")
DEX_FILE    = os.path.join(BASE, "DexData.txt")       # not required for bests; we derive from catches
PLAYER_FILE = os.path.join(BASE, "PlayerData.txt")

EXPORT = os.path.expanduser(r"C:\Users\sdmac\SD Mac Tech LLC IUL Dropbox\Mac McAhren\LBFD")
os.makedirs(EXPORT, exist_ok=True)

# Default “season” start = Aug 1 of current year at 00:00:00 local time
_now_local = datetime.datetime.now()
_SEASON_GUESS = datetime.datetime(_now_local.year, 8, 1, 0, 0, 0)
SEASON_START_EPOCH = int(_SEASON_GUESS.timestamp())

# ---------- IO HELPERS ----------
def _read_json_any(path):
    """Read JSON tolerant to BOM and empty files. Returns [] or {} on failure."""
    if not os.path.exists(path) or os.path.getsize(path) == 0:
        print(f"[read] {path} (missing/empty) -> []")
        return []
    # Try utf-8-sig first to strip potential BOM
    for enc in ("utf-8-sig", "utf-8"):
        try:
            with open(path, "r", encoding=enc) as f:
                data = json.load(f)
                kind = "list" if isinstance(data, list) else "dict" if isinstance(data, dict) else type(data).__name__
                size = len(data) if hasattr(data, "__len__") else "?"
                print(f"[read] {path} ({enc}) -> type={kind} size={size}")
                return data
        except Exception as e:
            last_err = e
            continue
    print(f"[read] {path} failed: {last_err}")
    return []

def _write_json(path, obj):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(obj, f, ensure_ascii=False, indent=2)
    rows = "dict" if isinstance(obj, dict) else len(obj)
    print(f"[write] {os.path.basename(path):14} -> {path} rows: {rows}")

# ---------- PARSING ----------
DATE_FMT = "%m/%d/%Y %I:%M:%S %p"  # e.g., 3/3/2024 5:05:48 PM (no leading zeros required)

def to_epoch_local(date_str):
    """
    Convert 'M/D/YYYY h:mm:ss AM/PM' to epoch seconds, interpreting the string as LOCAL time.
    This makes your browser display match what the game wrote.
    """
    if not date_str:
        return 0
    try:
        # strptime returns naive dt; .timestamp() treats it as local time
        dt = datetime.datetime.strptime(date_str, DATE_FMT)
        return int(dt.timestamp())
    except Exception:
        # last chance: ISO or anything Date.parse() might accept
        try:
            # handle already-epoch numbers in string
            if date_str.isdigit():
                return int(date_str)
        except Exception:
            pass
    return 0

def load_catches():
    raw = _read_json_any(CATCH_FILE)
    # Expecting a list of dicts with keys: username, name, value, rating, rarity, date
    catches = []
    if isinstance(raw, list):
        for d in raw:
            if not isinstance(d, dict):
                continue
            player = d.get("username") or d.get("player") or d.get("name_user") or "unknown"
            item   = d.get("name") or d.get("item") or d.get("species") or ""
            gold   = float(d.get("value") or d.get("gold") or 0)
            stars  = int(d.get("rating") or d.get("stars") or 0)
            rarity = d.get("rarity") or ""
            ts     = to_epoch_local(d.get("date") or d.get("time") or d.get("timestamp"))
            catches.append({
                "player": player,
                "item": item,
                "rarity": rarity,
                "stars": stars,
                "gold": gold,
                "timestamp": ts
            })
    print(f"[catches] loaded: {len(catches)}")
    return catches

def build_recent(catches, limit=50):
    # newest first
    rows = sorted(catches, key=lambda c: c.get("timestamp", 0), reverse=True)
    return rows[:limit]

def build_season_bests_from_catches(catches):
    """
    Best gold per species (all-time), including rarity, player, and the timestamp of the best record.
    """
    best_by_item = {}
    for c in catches:
        key = (c.get("item") or "").strip()
        if not key:
            continue
        g = float(c.get("gold") or 0)
        cur = best_by_item.get(key)
        # If higher gold, or same gold but newer timestamp, replace
        if cur is None or g > cur["best_gold"] or (g == cur["best_gold"] and c.get("timestamp", 0) > cur.get("timestamp", 0)):
            best_by_item[key] = {
                "item": key,
                "rarity": c.get("rarity") or "",
                "player": c.get("player") or "",
                "best_gold": g,
                "timestamp": int(c.get("timestamp") or 0)
            }
    # list sorted by best_gold desc
    out = list(best_by_item.values())
    out.sort(key=lambda r: r["best_gold"], reverse=True)
    return out

def build_players_and_leaderboard(catches, season_start_epoch):
    """
    Aggregate from catches so it's always correct.
    - players.json: season + lifetime stats
    - leaderboard.json: ranks by SEASON gold
    """
    life_gold = defaultdict(float)
    life_cast = defaultdict(int)
    seas_gold = defaultdict(float)
    seas_cast = defaultdict(int)

    for c in catches:
        p = c.get("player") or "unknown"
        g = float(c.get("gold") or 0)
        life_gold[p] += g
        life_cast[p] += 1
        if int(c.get("timestamp") or 0) >= int(season_start_epoch):
            seas_gold[p] += g
            seas_cast[p] += 1

    players = []
    for p in life_gold.keys() | seas_gold.keys():
        players.append({
            "name": p,
            "gold": round(seas_gold[p], 2),          # season gold (this is what your site shows in Players table)
            "casts": seas_cast[p],                   # season casts
            "lifetime_casts": life_cast[p],          # total casts
            "total_gold": round(life_gold[p], 2)     # optional, handy if you want all-time later
        })

    # leaderboard based on SEASON gold
    leaderboard = [{"player": r["name"], "gold": r["gold"]} for r in players]
    leaderboard.sort(key=lambda r: r["gold"], reverse=True)
    for i, r in enumerate(leaderboard, start=1):
        r["rank"] = i

    return players, leaderboard

# ---------- MAIN ----------
def main():
    catches = load_catches()

    # Build outputs
    recent        = build_recent(catches, limit=50)
    season_bests  = build_season_bests_from_catches(catches)
    players, leaderboard = build_players_and_leaderboard(catches, SEASON_START_EPOCH)

    # Meta
    now_epoch = int(time.time())
    now_iso   = datetime.datetime.utcnow().isoformat() + "Z"
    meta = {
        "exported_at_epoch": now_epoch,
        "exported_at_iso": now_iso,
        "season_start_epoch": SEASON_START_EPOCH
    }

    # Write
    _write_json(os.path.join(EXPORT, "recent.json"),        recent)
    _write_json(os.path.join(EXPORT, "season_bests.json"),  season_bests)
    _write_json(os.path.join(EXPORT, "players.json"),       players)
    _write_json(os.path.join(EXPORT, "leaderboard.json"),   leaderboard)
    _write_json(os.path.join(EXPORT, "meta.json"),          meta)

    print("")
    print(f"Exported counts -> recent:{len(recent)} bests:{len(season_bests)} players:{len(players)} leaderboard:{len(leaderboard)}")
    print(f"Exported to: {EXPORT}")

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print("FATAL:", e)
        sys.exit(1)
